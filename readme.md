data.py 创建dataset

---
makelabel.py 融合数字和背景，并保存，其中一张背景随机在四个象限加一个数字，几乎没有重叠，标签形状为（32，32，11），32*32是热图输出的大小，也就是一个热图的像素对应到原图是4*4的方格，每一个方格都充当一个分类器，分出11类，0-9是对应的数字，10为背景。

- fusion_img融合一个数字到一张背景图的随机位置
- fusion_4img考虑到一个数字太少，所以又写了四个数字的，输入参数是（背景，（图片1，标签1），（图片2，标签2）...），输出为图片（0-255）和标签

---
model.py 模型 最终占用192kb内存

---
test.py 测试脚本 开始是两个定义的函数，之后加载模型，有单张测试和视频测试，用哪个注释另外一个

- onepoint 输入一个矩阵和点的xy坐标，逐行扫描该点周围6行的像素，如果为1，说明有物体，把为1的这一格的xy加入数组后再置零，扫描周围6行后，如果总的点超过10个，认为是一个物体，就对所有的xy分别求平均，大概就是该物体的中心

1. 单张图片后处理过程，拿到输出的32*32*11的矩阵，先扫描一遍32*32，对每一行取argmax，如果不属于背景类，说明该处可能存在物理，再设定一个阈值，再次过滤到一部分误识别的框，之后将该点的值置为1，作为标记
2. 再次扫描矩阵，之前是扫描6行的点，为了不越界，只能用6开始，25结束，如果扫描到1，比如（20，20，3）这一格是1，那么取矩阵对应3的那一层，大小是32*32，把该矩阵和（20，20）的坐标传入之前的函数，返回的就是中心，类别就是3。不用担心误判，如果一个数字有两个可能，除非55开，两种像素数都大于10，会输出两个数字，不然一般都只输出一个数字。
3. 从第6行开始扫，对边界的一些数组判断的不好，但是没什么太均衡的办法
